# Install a published Replicated application via kubectl-kots.
#
# Runs kubectl-kots with the given license and configuration and waits for deployment.
#
# If no application configuration file is given, a very basic configuration file is
# generated by the task, using the given password, for automated installation.
#
# The `kubectl-kots install` will also install the Replicated Kots admin-console as
# a side effect if not already installed into the cluster.
#
# Because `kubectl-kots install` is not an idempotent operation, if the plan
# detects that the application has already been installed, it will skip this
# step and simply wait for the application to be ready.
#
# @param targets
#   The hosts to operate on.
# @param license_file
#   Path to the application license file.
# @param password
#   Password to use for both the Kots admin-console and for the application itself
#   (if not present in the config_file). If no password is given, one will be
#   randomly generated, and you will need to use `kubectl kots reset-password`.
# @param config_file
#   Path to application configuration defaults. If not provided, a basic config
#   will be generated by the install task.
# @param airgap_bundle
#   Installs the application from an airgap bundle.
# @param wait_for_app
#   Whether or not to wait for app deployment to complete before returning.
plan pam_tools::install_published(
  TargetSpec $targets,
  String $license_file,
  Optional[String[6]] $password = undef,
  Optional[String] $config_file = undef,
  Optional[String] $airgap_bundle = undef,
  Boolean $wait_for_app = true,
) {
  pam_tools::check_for_file('Bundle', $airgap_bundle, false)
  pam_tools::check_for_file('License', $license_file)

  $license_content = file::read($license_file)
  $kots_slug = pam_tools::get_kots_slug($license_content)
  $kots_app = pam_tools::get_kots_app($license_content)

  $status_results = run_task('pam_tools::get_kots_app_status', $targets, {
    'kots_slug' => $kots_slug,
  })
  $install_targets = $status_results.filter_set() |$result| {
    $result.message() == 'not-installed'
  }.targets()

  if $airgap_bundle {
    $target_bundle = "/tmp/${kots_app}.airgap"
    upload_file($airgap_bundle, $target_bundle, $install_targets)
  } else {
    $target_bundle = undef
  }

  $_password = $password =~ Undef ? {
    true  => pam_tools::generate_random_password(16),
    false => $password,
  }

  $base_install_options = {
    'license_content' => $license_content,
    'password'        => $_password,
    'airgap_bundle'   => $target_bundle,
  }
  $install_options = $config_file =~ NotUndef ? {
    true    => $base_install_options + { 'config_content' => file::read($config_file) },
    default => $base_install_options,
  }
  $install_results = run_task_with('pam_tools::kots_install', $install_targets) |$t| {
    $install_options + { 'hostname' => $t.name }
  }

  if $wait_for_app {
    if $install_results.empty() {
      out::message('All targets already installed.')
    } else {
      get_targets($targets).each |$t| {
        $result = $install_results.find($t.name)
        if $result =~ NotUndef {
          $appname = $result.value()['appname']
          out::message("Installed ${appname} on ${t}")
          out::message("${result.value()['output']}")
        }
      }
    }

    out::message('Waiting for deployment(s) to complete...(this may take several minutes)')

    $wait_results = run_task_with('pam_tools::wait_for_app', $targets) |$t| {
      {
        'kots_slug'    => $kots_slug,
        'app_hostname' => $t.name,
      }
    }
  } else {
    $wait_results = {
      'status' => 'skipped',
    }
  }

  if $password =~ Undef {
    out::message(@("EOM"))
      ** Because no password was given, a random password was generated: ${_password}
      ** You can reset this with `kubectl kots reset-password`)
    |- EOM
  }

  $results = {
    'kots_slug'          => $kots_slug,
    'kots_app'           => $kots_app,
    'install_result_set' => $install_results,
    'wait_result_set'    => $wait_results,
  }
  return $results
}
