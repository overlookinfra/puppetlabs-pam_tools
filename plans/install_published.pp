# Install a published Replicated application via kubectl-kots.
#
# Runs kubectl-kots with the given license and configuration and waits for
# deployment.
#
# If no application configuration file is given, a very basic configuration file is
# generated by the task, using the given password, for automated installation.
#
# The `kubectl-kots install` will also install the Replicated Kots admin-console as
# a side effect if not already installed into the cluster. Initial configuration
# for Kots comes from one of the puppet-application-manager channels as determined
# by the +pam_variant+ parameter. By default Kots is installed with
# puppet-application-manager/stable.
#
# Because `kubectl-kots install` is not an idempotent operation, if the plan
# detects that the application has already been installed, it will skip this
# step and simply wait for the application to be ready.
#
# @param targets
#   The hosts to operate on.
# @param license_file
#   Path to the application license file.
# @param password
#   Password to use for both the Kots admin-console and for the application itself
#   (if not present in the config_file). If no password is given, one will be
#   randomly generated, and you will need to use `kubectl kots reset-password`.
# @param config_file
#   Absolute path to application configuration defaults. If not provided, a
#   basic config will be generated by the install task.
# @param airgap_bundle
#   Installs the application from an airgap bundle. Must be an absolute path.
# @param kots_install_options
#   Any additional command line options to pass directly to `kubectl-kots
#   install` when the kots_install task is run. (--skip-preflights=true, or
#   --skip-rbac-check=true, for example...)
# @param pam_variant
#   The initial puppet-application-manager channel that will provide
#   configuration for Kots itself prior to Kots installing the application
#   identified by the +license_content+. This can be important for a
#   GKE cluster, for example, which will require 'minimal-rbac' instead of
#   'stable' unless the service-account used has permissions to modify
#   clusteroles.
# @param allocated_memory_in_gigabytes
#   The total system memory being made available to the application.
#   This should be in integer or float gigabytes. This is used to
#   tune configuration for the app. It will be ignored if you are
#   supplying your own +config_file+, or for any application other
#   than Connect.
# @param allocated_cpu
#   The total number of cpu available to the application. This should
#   be whole or Float fractional cpu, but not millicpu. Currently the
#   only affect is to tighten comply cpu requests to allow it to stand up
#   with <= 4 cpu.
# @param wait_for_app
#   Whether or not to wait for app deployment to complete before returning.
# @param app_timeout
#   If waiting for the app, this is the number of seconds to wait for kots
#   to indicate that the app is ready.
plan pam_tools::install_published(
  TargetSpec $targets,
  Pam_tools::Absolute_path $license_file,
  Optional[String[6]] $password = undef,
  Optional[Pam_tools::Absolute_path] $config_file = undef,
  Optional[Pam_tools::Absolute_path] $airgap_bundle = undef,
  Optional[String] $kots_install_options = undef,
  String $pam_variant = 'stable',
  Variant[Integer,Float] $allocated_memory_in_gigabytes = 16,
  Variant[Integer,Float] $allocated_cpu = 8,
  Boolean $wait_for_app = true,
  Integer $app_timeout = 600,
) {
  pam_tools::check_for_file('License', $license_file)
  pam_tools::check_for_file('Config', $config_file, false)
  pam_tools::check_for_file('Bundle', $airgap_bundle, false)

  $license_content = file::read($license_file)
  $kots_slug = pam_tools::get_kots_slug($license_content)
  $kots_app = pam_tools::get_kots_app($license_content)

  $status_results = run_task('pam_tools::get_kots_app_status', $targets, {
    'kots_slug' => $kots_slug,
  })
  $install_targets = $status_results.filter_set() |$result| {
    $result.message() == 'not-installed'
  }.targets()

  if $airgap_bundle {
    $target_bundle = "/tmp/${kots_app}.airgap"
    upload_file($airgap_bundle, $target_bundle, $install_targets)
  } else {
    $target_bundle = undef
  }

  $_password = $password =~ Undef ? {
    true  => pam_tools::generate_random_password(16),
    false => $password,
  }

  $base_install_options = {
    'license_content'      => $license_content,
    'password'             => $_password,
    'airgap_bundle'        => $target_bundle,
    'kots_install_options' => $kots_install_options,
    'pam_variant'          => $pam_variant,
  }
  $install_results = run_task_with('pam_tools::kots_install', $install_targets) |$t| {
    case $config_file {
      NotUndef: {
        $config_content = file::read($config_file)
      }
      default: {
        $config_content = epp(
          'pam_tools/default-app-config.yaml.epp',
          {
            'kots_app'                      => $kots_app,
            'hostname'                      => $t.name,
            'password'                      => $_password,
            'allocated_memory_in_gigabytes' => $allocated_memory_in_gigabytes,
            'allocated_cpu'                 => $allocated_cpu,
          }
        )
      }
    }
    $base_install_options + {
      'config_content' => $config_content,
      'hostname'       => $t.name,
    }
  }

  if $wait_for_app {
    if $install_results.empty() {
      out::message('All targets already installed.')
    } else {
      get_targets($targets).each |$t| {
        $result = $install_results.find($t.name)
        if $result =~ NotUndef {
          $appname = $result.value()['appname']
          out::message("Installed ${appname} on ${t}")
          out::message("${result.value()['output']}")
        }
      }
    }

    out::message('Waiting for deployment(s) to complete...(this may take several minutes)')

    $wait_results = run_task_with('pam_tools::wait_for_app', $targets) |$t| {
      {
        'kots_slug'    => $kots_slug,
        'app_hostname' => $t.name,
        'app_timeout'  => "${app_timeout}s",
      }
    }
  } else {
    $wait_results = {
      'status' => 'skipped',
    }
  }

  if $password =~ Undef {
    out::message(@("EOM"))
      ** Because no password was given, a random password was generated: ${_password}
      ** You can reset this with `kubectl kots reset-password`)
    |- EOM
  }

  $results = {
    'kots_slug'          => $kots_slug,
    'kots_app'           => $kots_app,
    'install_result_set' => $install_results,
    'wait_result_set'    => $wait_results,
  }
  return $results
}
